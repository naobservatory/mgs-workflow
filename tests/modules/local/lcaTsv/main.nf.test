def filter_tab = { tab_in, group_field, group_id -> csv(tab_in.table.where(
    tab_in.table.stringColumn(group_field).isEqualTo(group_id)
    ))}

nextflow_process {

    name "Test process LCA_TSV"
    script "modules/local/lcaTsv/main.nf"
    process "LCA_TSV"
    config "tests/configs/run.config"
    tag "module"
    tag "lca_tsv"

    test("Should run without errors and produce expected output when run on valid input"){
        tag "expect_success"
        when {
            params {
                input_path = "${projectDir}/test-data/toy-data/lca-taxonomy/test-input.tsv"
                db_path = "${projectDir}/test-data/toy-data/lca-taxonomy/test-nodes.dmp"
                group_field = "seq_id"
                taxid_field = "taxid"
                score_field = "test_score"
            }
            process {
                '''
                input[0] = Channel.of("test")
                    | combine(Channel.of(params.input_path))
                input[1] = params.db_path
                input[2] = params.group_field
                input[3] = params.taxid_field
                input[4] = params.score_field
                '''
            }
        }
        then {
            // Should run without errors
            assert process.success
            // Output should have one row per input group
            def tab_in = path(process.out.input[0][1]).csv(sep: "\t")
            def tab_out = path(process.out.output[0][1]).csv(sep: "\t")
            def groups = tab_in.columns[params.group_field].unique()
            assert tab_out.rowCount == groups.size()
            // Output should have expected column names
            def exp_headers = ["group_id", "lca", "n_entries", "min_score", "max_score", "mean_score"]
            assert tab_out.columnNames == exp_headers
            // Output should have expected column values
            for (group in groups) {
                def tab_in_filtered = filter_tab(tab_in, params.group_field, group)
                def tab_out_filtered = filter_tab(tab_out, "group_id", group)
                assert tab_out_filtered.rowCount == 1
                def exp_lca = tab_in_filtered.columns["exp_lca"][0]
                def exp_n_entries = tab_in_filtered.rowCount
                def exp_min_score = tab_in_filtered.columns[params.score_field].min()
                def exp_max_score = tab_in_filtered.columns[params.score_field].max()
                def exp_mean_score = tab_in_filtered.columns[params.score_field].sum() / exp_n_entries
                assert tab_out_filtered.columns["group_id"][0] == group
                assert tab_out_filtered.columns["lca"][0] == exp_lca
                assert tab_out_filtered.columns["n_entries"][0] == exp_n_entries
                assert tab_out_filtered.columns["min_score"][0] == exp_min_score
                assert tab_out_filtered.columns["max_score"][0] == exp_max_score
                assert tab_out_filtered.columns["mean_score"][0] == exp_mean_score
            }
        }
    }

    test("Should break when group field is missing from input"){
        tag "expect_failed"
        when {
            params {
                input_path = "${projectDir}/test-data/toy-data/lca-taxonomy/test-input.tsv"
                db_path = "${projectDir}/test-data/toy-data/lca-taxonomy/test-nodes.dmp"
                group_field = "missing"
                taxid_field = "taxid"
                score_field = "test_score"
            }
            process {
                '''
                input[0] = Channel.of("test")
                    | combine(Channel.of(params.input_path))
                input[1] = params.db_path
                input[2] = params.group_field
                input[3] = params.taxid_field
                input[4] = params.score_field
                '''
            }
        }
        then {
            assert process.failed
            assert process.exitStatus == 1
            assert process.errorReport.contains("AssertionError: Group field not found in header")
            assert !process.errorReport.contains("AssertionError: Taxid field not found in header")
        }
    }

    test("Should break when taxid field is missing from input"){
        tag "expect_failed"
        when {
            params {
                input_path = "${projectDir}/test-data/toy-data/lca-taxonomy/test-input.tsv"
                db_path = "${projectDir}/test-data/toy-data/lca-taxonomy/test-nodes.dmp"
                group_field = "seq_id"
                taxid_field = "missing"
                score_field = "test_score"
            }
            process {
                '''
                input[0] = Channel.of("test")
                    | combine(Channel.of(params.input_path))
                input[1] = params.db_path
                input[2] = params.group_field
                input[3] = params.taxid_field
                input[4] = params.score_field
                '''
            }
        }
        then {
            assert process.failed
            assert process.exitStatus == 1
            assert process.errorReport.contains("AssertionError: Taxid field not found in header")
            assert !process.errorReport.contains("AssertionError: Group field not found in header")
        }
    }

    test("Should break when score field is missing from input"){
        tag "expect_failed"
        when {
            params {
                input_path = "${projectDir}/test-data/toy-data/lca-taxonomy/test-input.tsv"
                db_path = "${projectDir}/test-data/toy-data/lca-taxonomy/test-nodes.dmp"
                group_field = "seq_id"
                taxid_field = "taxid"
                score_field = "missing"
            }
            process {
                '''
                input[0] = Channel.of("test")
                    | combine(Channel.of(params.input_path))
                input[1] = params.db_path
                input[2] = params.group_field
                input[3] = params.taxid_field
                input[4] = params.score_field
                '''
            }
        }
        then {
            assert process.failed
            assert process.exitStatus == 1
            assert process.errorReport.contains("AssertionError: Score field not found in header")
            assert !process.errorReport.contains("AssertionError: Group field not found in header")
        }
    }

    test("Should break when root is missing from taxonomy DB"){
        tag "expect_failed"
        when {
            params {
                input_path = "${projectDir}/test-data/toy-data/lca-taxonomy/test-input.tsv"
                db_path = "${projectDir}/test-data/toy-data/lca-taxonomy/test-nodes-truncated.dmp"
                group_field = "seq_id"
                taxid_field = "taxid"
                score_field = "test_score"
            }
            process {
                '''
                input[0] = Channel.of("test")
                    | combine(Channel.of(params.input_path))
                input[1] = params.db_path
                input[2] = params.group_field
                input[3] = params.taxid_field
                input[4] = params.score_field
                '''
            }
        }
        then {
            assert process.failed
            assert process.exitStatus == 1
            assert process.errorReport.contains("AssertionError: Taxonomy DB does not contain root")
            assert !process.errorReport.contains("AssertionError: Group field not found in header")
        }
    }

    test("Should break when input TSV is not sorted by group field"){
        tag "expect_failed"
        when {
            params {
                input_path = "${projectDir}/test-data/toy-data/lca-taxonomy/test-input-unsorted.tsv"
                db_path = "${projectDir}/test-data/toy-data/lca-taxonomy/test-nodes.dmp"
                group_field = "seq_id"
                taxid_field = "taxid"
                score_field = "test_score"
            }
            process {
                '''
                input[0] = Channel.of("test")
                    | combine(Channel.of(params.input_path))
                input[1] = params.db_path
                input[2] = params.group_field
                input[3] = params.taxid_field
                input[4] = params.score_field
                '''
            }
        }
        then {
            assert process.failed
            assert process.exitStatus == 1
            assert process.errorReport.contains("AssertionError: Group ID out of order")
            assert !process.errorReport.contains("AssertionError: Group field not found in header")
        }
    }

}