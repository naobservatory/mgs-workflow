// Helper function: filter table by column value
def filter_by_column_value = { tab_in, column_name, filter_value, keep_matching -> 
    def column = tab_in.table.column(column_name)
    def filtered_rows
    // Handle different column types specially
    if (column.type().name() == "BOOLEAN") {
        // For boolean columns, use isTrue() or isFalse() methods
        def boolValue = filter_value.toLowerCase() == "true"
        if (boolValue) {
            filtered_rows = keep_matching ? tab_in.table.where(column.isTrue()) : tab_in.table.where(column.isFalse())
        } else {
            filtered_rows = keep_matching ? tab_in.table.where(column.isFalse()) : tab_in.table.where(column.isTrue())
        }
    } else if (column.type().name() == "INTEGER") {
        // For integer columns, ensure filter_value is an integer
        def intValue = filter_value instanceof Integer ? filter_value : Integer.parseInt(filter_value.toString())
        filtered_rows = keep_matching ? tab_in.table.where(column.isEqualTo(intValue)) : tab_in.table.where(column.isNotEqualTo(intValue))
    } else if (column.type().name() == "DOUBLE") {
        // For double columns, ensure filter_value is a double
        def doubleValue = filter_value instanceof Double ? filter_value : Double.parseDouble(filter_value.toString())
        filtered_rows = keep_matching ? tab_in.table.where(column.isEqualTo(doubleValue)) : tab_in.table.where(column.isNotEqualTo(doubleValue))
    } else {
        // For string and other columns
        filtered_rows = keep_matching ? tab_in.table.where(column.isEqualTo(filter_value)) : tab_in.table.where(column.isNotEqualTo(filter_value))
    }
    return csv(filtered_rows)
}

nextflow_process {

    name "Test process FILTER_TSV_COLUMN_BY_VALUE"
    script "modules/local/filterTsvColumnByValue/main.nf"
    process "FILTER_TSV_COLUMN_BY_VALUE"
    config "tests/configs/run.config"
    tag "module"
    tag "filter_tsv_column_by_value"

    test("Should handle completely empty file (keep_matching = true)") {
        tag "expect_success"
        tag "empty_file"
        
        when {
            params {
                column_name = "test_column"
                filter_value = "test_value"
                keep_matching = true
            }
            process {
                '''
                input[0] = Channel.of("test")
                    | combine(Channel.of("${projectDir}/test-data/toy-data/empty_file.txt"))
                input[1] = params.column_name
                input[2] = params.filter_value
                input[3] = params.keep_matching
                '''
            }
        }
        then {
            // Should run without failures
            assert process.success
            
            // Output file should exist but be empty
            def output_file = path(process.out.output[0][1])
            assert output_file.exists()
            assert output_file.text.size() == 0
        }
    }

    test("Should handle header-only input file (keep_matching = true)") {
        tag "expect_success" 
        tag "header_only"
        
        when {
            params {
                column_name = "x"
                filter_value = "test_value"
                keep_matching = true
            }
            process {
                '''
                input[0] = Channel.of("test")
                    | combine(Channel.of("${projectDir}/test-data/toy-data/test_tab_empty.tsv"))
                input[1] = params.column_name
                input[2] = params.filter_value
                input[3] = params.keep_matching
                '''
            }
        }
        then {
            // Should run without failures
            assert process.success
            
            // Output should have correct header only
            def output_file = path(process.out.output[0][1])
            
            // Read the file manually to avoid issues with compressed file handling
            def content = output_file.text.split("\n")
            
            // There should be only a header line
            assert content.size() == 1
            
            // Header should have the expected columns
            def header_fields = content[0].split("\t")
            assert header_fields.size() == 3
            assert header_fields[0] == "x"
            assert header_fields[1] == "y"
            assert header_fields[2] == "z"
        }
    }

    test("Should fail when specified column is missing (keep_matching = true)") {
        tag "expect_failed"
        tag "missing_column"
        
        when {
            params {
                column_name = "nonexistent_column"
                filter_value = "false"
                keep_matching = true
            }
            process {
                '''
                input[0] = Channel.of("test")
                    | combine(Channel.of("${projectDir}/test-data/toy-data/test_tab_sorted.tsv"))
                input[1] = params.column_name
                input[2] = params.filter_value
                input[3] = params.keep_matching
                '''
            }
        }
        then {
            assert process.failed
            assert process.exitStatus == 1
            assert process.errorReport.contains("Column '${params.column_name}' not found in header")
        }
    }

    test("Should filter column successfully (by removing all rows, keep_matching = true)") {
        tag "expect_success"
        tag "keep_no_rows"
        
        when {
            params {
                column_name = "x"
                filter_value = 5
                keep_matching = true
            }
            process {
                '''
                input[0] = Channel.of("test")
                    | combine(Channel.of("${projectDir}/test-data/toy-data/test_tab_sorted.tsv"))
                input[1] = params.column_name
                input[2] = params.filter_value
                input[3] = params.keep_matching
                '''
            }
        }
        then {
            // Should run without errors
            assert process.success
            
            // Generate expected output from input using helper function
            def tab_in = path(process.out.input[0][1]).csv(sep: "\t")
            def tab_exp = filter_by_column_value(tab_in, params.column_name, params.filter_value, params.keep_matching)
            
            // Since this test expects no matching rows (header-only output), handle manually
            def output_file = path(process.out.output[0][1])
            def content = output_file.text.split("\n")
            
            // Should have only header line (no data rows)
            assert content.size() == 1
            
            // Header should have the expected columns
            def header_fields = content[0].split("\t")
            assert header_fields.size() == 3
            assert header_fields[0] == "x"
            assert header_fields[1] == "y" 
            assert header_fields[2] == "z"
            
            // Verify expected result also has 0 rows
            assert tab_exp.rowCount == 0
        }
    }

    test("Should filter column successfully (by keeping rows with matching value, keep_matching = true)") {
        tag "expect_success"
        tag "keep_rows"
        
        when {
            params {
                column_name = "x"
                filter_value = 6
                keep_matching = true
            }
            process {
                '''
                input[0] = Channel.of("test")
                    | combine(Channel.of("${projectDir}/test-data/toy-data/test_tab_sorted.tsv"))
                input[1] = params.column_name
                input[2] = params.filter_value
                input[3] = params.keep_matching
                '''
            }
        }
        then {
            // Should run without errors
            assert process.success
            
            // Generate expected output from input using helper function
            def tab_in = path(process.out.input[0][1]).csv(sep: "\t")
            def tab_out = path(process.out.output[0][1]).csv(sep: "\t")
            def tab_exp = filter_by_column_value(tab_in, params.column_name, params.filter_value, params.keep_matching)
            
            // Compare output with expected filtered input
            assert tab_out.columnCount == tab_exp.columnCount
            assert tab_out.rowCount == tab_exp.rowCount
            assertTableEquals tab_exp, tab_out
            
            // Check that all output rows have expected filter value
            def filterColumn = tab_out.columns[params.column_name]
            for (value in filterColumn) {
                assert value == params.filter_value
            }
        }
    }

    test("Should discard rows with matching value (keep_matching = false)") {
        tag "expect_success"
        tag "discard_matching"
        
        when {
            params {
                column_name = "x"
                filter_value = 6
                keep_matching = false
            }
            process {
                '''
                input[0] = Channel.of("test")
                    | combine(Channel.of("${projectDir}/test-data/toy-data/test_tab_sorted.tsv"))
                input[1] = params.column_name
                input[2] = params.filter_value
                input[3] = params.keep_matching
                '''
            }
        }
        then {
            // Should run without errors
            assert process.success
            
            // Generate expected output from input using helper function
            def tab_in = path(process.out.input[0][1]).csv(sep: "\t")
            def tab_out = path(process.out.output[0][1]).csv(sep: "\t")
            def tab_exp = filter_by_column_value(tab_in, params.column_name, params.filter_value, params.keep_matching)
            
            // Compare output with expected filtered input
            assert tab_out.columnCount == tab_exp.columnCount
            assert tab_out.rowCount == tab_exp.rowCount
            assertTableEquals tab_exp, tab_out
            
            // Check that NO output rows have the filter value (they should all be discarded)
            def filterColumn = tab_out.columns[params.column_name]
            for (value in filterColumn) {
                assert value != params.filter_value
            }
        }
    }


}
