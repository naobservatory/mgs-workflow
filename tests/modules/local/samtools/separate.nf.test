nextflow_process {

    name "Test process SAMTOOLS_SEPARATE"
    script "modules/local/samtools/main.nf"
    process "SAMTOOLS_SEPARATE"
    config "tests/run_dev_se.config"
    tag "module"
    tag "samtools"

    setup {
        run("LOAD_SAMPLESHEET") {
            script "subworkflows/local/loadSampleSheet/main.nf"
            process {
                """
                input[0] = "${projectDir}/test-data/ont-samplesheet.csv"
                input[1] = true
                """
            }
        }
        run("MINIMAP2_ONT") {
            script "modules/local/minimap2/main.nf"
            process {
                """
                input[0] = LOAD_SAMPLESHEET.out.samplesheet
                input[1] = "s3://nao-mgs-simon/ont-indices/2024-12-14/minimap2-human-index/chm13v2.0.mmi"
                input[2] = "human"
                """
            }
        }
    }

    test("When run on a SAM file, should return aligned and unaligned reads separately") {
        tag "expect_success"
        tag "single_end"
        when {
            params {}
            process {
                '''
                input[0] = MINIMAP2_ONT.out.sam
                input[1] = "no-human"
                '''
            }
        }
        then {
            // Should run without failures
            assert process.success

            // The two FASTQ output files should contain read ids of mapped and unmapped reads, respectively
            def fastq_match = path(process.out.match[0][1]).fastq
            def fastq_nomatch = path(process.out.nomatch[0][1]).fastq
            def read_ids_match = fastq_match.readNames.toSet()
            def read_ids_nomatch = fastq_nomatch.readNames.toSet()

            def samlines = sam(process.out.input[0][1]).getSamLines()
            def unmapped_read_ids = samlines
                .findAll { line -> line.split('\t')[1] == '4' }  // Only keep lines where flag = 4
                .collect { line -> line.split('\t')[0] }         // Get read IDs
                .toSet()                                  // Convert to Set to remove duplicates
            def mapped_read_ids = samlines
                .findAll { line -> line.split('\t')[1] != '4' }  // Only keep lines where flag != 4
                .collect { line -> line.split('\t')[0] }         // Get read IDs
                .toSet()

            assert read_ids_nomatch == unmapped_read_ids
            assert read_ids_match == mapped_read_ids

            // The two FASTQ files should not contain any overlapping read ids
            assert read_ids_match.intersect(read_ids_nomatch).size() == 0
        }
    }
}
